// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: reads.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getActiveRewards = `-- name: GetActiveRewards :many
select id, address, index, tx_hash, sender, reward_id, name, amount, claim_authorities, raw_message, block_height, created_at, updated_at
from core_rewards
order by address
`

func (q *Queries) GetActiveRewards(ctx context.Context) ([]CoreReward, error) {
	rows, err := q.db.Query(ctx, getActiveRewards)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CoreReward
	for rows.Next() {
		var i CoreReward
		if err := rows.Scan(
			&i.ID,
			&i.Address,
			&i.Index,
			&i.TxHash,
			&i.Sender,
			&i.RewardID,
			&i.Name,
			&i.Amount,
			&i.ClaimAuthorities,
			&i.RawMessage,
			&i.BlockHeight,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllEthAddressesOfRegisteredNodes = `-- name: GetAllEthAddressesOfRegisteredNodes :many
select eth_address
from core_validators
`

func (q *Queries) GetAllEthAddressesOfRegisteredNodes(ctx context.Context) ([]string, error) {
	rows, err := q.db.Query(ctx, getAllEthAddressesOfRegisteredNodes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var eth_address string
		if err := rows.Scan(&eth_address); err != nil {
			return nil, err
		}
		items = append(items, eth_address)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllRegisteredNodes = `-- name: GetAllRegisteredNodes :many
select rowid, pub_key, endpoint, eth_address, comet_address, eth_block, node_type, sp_id, comet_pub_key
from core_validators
`

func (q *Queries) GetAllRegisteredNodes(ctx context.Context) ([]CoreValidator, error) {
	rows, err := q.db.Query(ctx, getAllRegisteredNodes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CoreValidator
	for rows.Next() {
		var i CoreValidator
		if err := rows.Scan(
			&i.Rowid,
			&i.PubKey,
			&i.Endpoint,
			&i.EthAddress,
			&i.CometAddress,
			&i.EthBlock,
			&i.NodeType,
			&i.SpID,
			&i.CometPubKey,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllRegisteredNodesSorted = `-- name: GetAllRegisteredNodesSorted :many
select rowid, pub_key, endpoint, eth_address, comet_address, eth_block, node_type, sp_id, comet_pub_key
from core_validators
order by comet_address
`

func (q *Queries) GetAllRegisteredNodesSorted(ctx context.Context) ([]CoreValidator, error) {
	rows, err := q.db.Query(ctx, getAllRegisteredNodesSorted)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CoreValidator
	for rows.Next() {
		var i CoreValidator
		if err := rows.Scan(
			&i.Rowid,
			&i.PubKey,
			&i.Endpoint,
			&i.EthAddress,
			&i.CometAddress,
			&i.EthBlock,
			&i.NodeType,
			&i.SpID,
			&i.CometPubKey,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllRewards = `-- name: GetAllRewards :many
select id, address, index, tx_hash, sender, reward_id, name, amount, claim_authorities, raw_message, block_height, created_at, updated_at from core_rewards
where address in (
    select distinct address
    from core_rewards
)
order by block_height desc
`

func (q *Queries) GetAllRewards(ctx context.Context) ([]CoreReward, error) {
	rows, err := q.db.Query(ctx, getAllRewards)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CoreReward
	for rows.Next() {
		var i CoreReward
		if err := rows.Scan(
			&i.ID,
			&i.Address,
			&i.Index,
			&i.TxHash,
			&i.Sender,
			&i.RewardID,
			&i.Name,
			&i.Amount,
			&i.ClaimAuthorities,
			&i.RawMessage,
			&i.BlockHeight,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAppStateAtHeight = `-- name: GetAppStateAtHeight :one
select block_height,
    app_hash
from core_app_state
where block_height = $1
limit 1
`

type GetAppStateAtHeightRow struct {
	BlockHeight int64
	AppHash     []byte
}

func (q *Queries) GetAppStateAtHeight(ctx context.Context, blockHeight int64) (GetAppStateAtHeightRow, error) {
	row := q.db.QueryRow(ctx, getAppStateAtHeight, blockHeight)
	var i GetAppStateAtHeightRow
	err := row.Scan(&i.BlockHeight, &i.AppHash)
	return i, err
}

const getAvailableCities = `-- name: GetAvailableCities :many
select city,
    region,
    country,
    count(*) as play_count
from core_etl_tx_plays
where city is not null
    and (
        nullif($1, '')::text is null
        or lower(country) = lower($1)
    )
    and (
        nullif($2, '')::text is null
        or lower(region) = lower($2)
    )
group by city,
    region,
    country
order by count(*) desc
limit $3
`

type GetAvailableCitiesParams struct {
	Column1 interface{}
	Column2 interface{}
	Limit   int32
}

type GetAvailableCitiesRow struct {
	City      pgtype.Text
	Region    pgtype.Text
	Country   pgtype.Text
	PlayCount int64
}

func (q *Queries) GetAvailableCities(ctx context.Context, arg GetAvailableCitiesParams) ([]GetAvailableCitiesRow, error) {
	rows, err := q.db.Query(ctx, getAvailableCities, arg.Column1, arg.Column2, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAvailableCitiesRow
	for rows.Next() {
		var i GetAvailableCitiesRow
		if err := rows.Scan(
			&i.City,
			&i.Region,
			&i.Country,
			&i.PlayCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAvailableCountries = `-- name: GetAvailableCountries :many
select country,
    count(*) as play_count
from core_etl_tx_plays
where country is not null
group by country
order by count(*) desc
limit $1
`

type GetAvailableCountriesRow struct {
	Country   pgtype.Text
	PlayCount int64
}

func (q *Queries) GetAvailableCountries(ctx context.Context, limit int32) ([]GetAvailableCountriesRow, error) {
	rows, err := q.db.Query(ctx, getAvailableCountries, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAvailableCountriesRow
	for rows.Next() {
		var i GetAvailableCountriesRow
		if err := rows.Scan(&i.Country, &i.PlayCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAvailableRegions = `-- name: GetAvailableRegions :many
select region,
    country,
    count(*) as play_count
from core_etl_tx_plays
where region is not null
    and (
        nullif($1, '')::text is null
        or lower(country) = lower($1)
    )
group by region,
    country
order by count(*) desc
limit $2
`

type GetAvailableRegionsParams struct {
	Column1 interface{}
	Limit   int32
}

type GetAvailableRegionsRow struct {
	Region    pgtype.Text
	Country   pgtype.Text
	PlayCount int64
}

func (q *Queries) GetAvailableRegions(ctx context.Context, arg GetAvailableRegionsParams) ([]GetAvailableRegionsRow, error) {
	rows, err := q.db.Query(ctx, getAvailableRegions, arg.Column1, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAvailableRegionsRow
	for rows.Next() {
		var i GetAvailableRegionsRow
		if err := rows.Scan(&i.Region, &i.Country, &i.PlayCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBlock = `-- name: GetBlock :one
select rowid, height, chain_id, hash, proposer, created_at
from core_blocks
where height = $1
`

func (q *Queries) GetBlock(ctx context.Context, height int64) (CoreBlock, error) {
	row := q.db.QueryRow(ctx, getBlock, height)
	var i CoreBlock
	err := row.Scan(
		&i.Rowid,
		&i.Height,
		&i.ChainID,
		&i.Hash,
		&i.Proposer,
		&i.CreatedAt,
	)
	return i, err
}

const getBlockTransactions = `-- name: GetBlockTransactions :many
select rowid, block_id, index, tx_hash, transaction, created_at
from core_transactions
where block_id = $1
order by created_at desc
`

func (q *Queries) GetBlockTransactions(ctx context.Context, blockID int64) ([]CoreTransaction, error) {
	rows, err := q.db.Query(ctx, getBlockTransactions, blockID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CoreTransaction
	for rows.Next() {
		var i CoreTransaction
		if err := rows.Scan(
			&i.Rowid,
			&i.BlockID,
			&i.Index,
			&i.TxHash,
			&i.Transaction,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBlocksWithTransactions = `-- name: GetBlocksWithTransactions :many
select
    b.rowid as block_rowid,
    b.height,
    b.chain_id,
    b.hash as block_hash,
    b.proposer,
    b.created_at as block_created_at,
    t.rowid as tx_rowid,
    t.block_id,
    t.index as tx_index,
    t.tx_hash,
    t.transaction,
    t.created_at as tx_created_at
from core_blocks b
left join core_transactions t on b.height = t.block_id
where b.height = any($1::bigint[])
order by b.height, t.created_at desc
`

type GetBlocksWithTransactionsRow struct {
	BlockRowid     int64
	Height         int64
	ChainID        string
	BlockHash      string
	Proposer       string
	BlockCreatedAt pgtype.Timestamp
	TxRowid        pgtype.Int8
	BlockID        pgtype.Int8
	TxIndex        pgtype.Int4
	TxHash         pgtype.Text
	Transaction    []byte
	TxCreatedAt    pgtype.Timestamp
}

func (q *Queries) GetBlocksWithTransactions(ctx context.Context, dollar_1 []int64) ([]GetBlocksWithTransactionsRow, error) {
	rows, err := q.db.Query(ctx, getBlocksWithTransactions, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBlocksWithTransactionsRow
	for rows.Next() {
		var i GetBlocksWithTransactionsRow
		if err := rows.Scan(
			&i.BlockRowid,
			&i.Height,
			&i.ChainID,
			&i.BlockHash,
			&i.Proposer,
			&i.BlockCreatedAt,
			&i.TxRowid,
			&i.BlockID,
			&i.TxIndex,
			&i.TxHash,
			&i.Transaction,
			&i.TxCreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCoreUpload = `-- name: GetCoreUpload :one
select id, uploader_address, cid, transcoded_cid, upid, upload_signature, validator_address, validator_signature, tx_hash, block_height from core_uploads where cid = $1 OR transcoded_cid = $1
`

func (q *Queries) GetCoreUpload(ctx context.Context, cid string) (CoreUpload, error) {
	row := q.db.QueryRow(ctx, getCoreUpload, cid)
	var i CoreUpload
	err := row.Scan(
		&i.ID,
		&i.UploaderAddress,
		&i.Cid,
		&i.TranscodedCid,
		&i.Upid,
		&i.UploadSignature,
		&i.ValidatorAddress,
		&i.ValidatorSignature,
		&i.TxHash,
		&i.BlockHeight,
	)
	return i, err
}

const getDBSize = `-- name: GetDBSize :one
select pg_database_size(current_database())::bigint as size
`

func (q *Queries) GetDBSize(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getDBSize)
	var size int64
	err := row.Scan(&size)
	return size, err
}

const getDecodedPlays = `-- name: GetDecodedPlays :many
select tx_hash,
    user_id,
    track_id,
    played_at,
    signature,
    city,
    region,
    country,
    created_at
from core_etl_tx_plays
order by played_at desc
limit $1
`

type GetDecodedPlaysRow struct {
	TxHash    string
	UserID    string
	TrackID   string
	PlayedAt  pgtype.Timestamptz
	Signature string
	City      pgtype.Text
	Region    pgtype.Text
	Country   pgtype.Text
	CreatedAt pgtype.Timestamptz
}

func (q *Queries) GetDecodedPlays(ctx context.Context, limit int32) ([]GetDecodedPlaysRow, error) {
	rows, err := q.db.Query(ctx, getDecodedPlays, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDecodedPlaysRow
	for rows.Next() {
		var i GetDecodedPlaysRow
		if err := rows.Scan(
			&i.TxHash,
			&i.UserID,
			&i.TrackID,
			&i.PlayedAt,
			&i.Signature,
			&i.City,
			&i.Region,
			&i.Country,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDecodedPlaysByLocation = `-- name: GetDecodedPlaysByLocation :many
select tx_hash,
    user_id,
    track_id,
    played_at,
    signature,
    city,
    region,
    country,
    created_at
from core_etl_tx_plays
where (
        nullif($1, '')::text is null
        or lower(city) = lower($1)
    )
    and (
        nullif($2, '')::text is null
        or lower(region) = lower($2)
    )
    and (
        nullif($3, '')::text is null
        or lower(country) = lower($3)
    )
order by played_at desc
limit $4
`

type GetDecodedPlaysByLocationParams struct {
	Column1 interface{}
	Column2 interface{}
	Column3 interface{}
	Limit   int32
}

type GetDecodedPlaysByLocationRow struct {
	TxHash    string
	UserID    string
	TrackID   string
	PlayedAt  pgtype.Timestamptz
	Signature string
	City      pgtype.Text
	Region    pgtype.Text
	Country   pgtype.Text
	CreatedAt pgtype.Timestamptz
}

func (q *Queries) GetDecodedPlaysByLocation(ctx context.Context, arg GetDecodedPlaysByLocationParams) ([]GetDecodedPlaysByLocationRow, error) {
	rows, err := q.db.Query(ctx, getDecodedPlaysByLocation,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDecodedPlaysByLocationRow
	for rows.Next() {
		var i GetDecodedPlaysByLocationRow
		if err := rows.Scan(
			&i.TxHash,
			&i.UserID,
			&i.TrackID,
			&i.PlayedAt,
			&i.Signature,
			&i.City,
			&i.Region,
			&i.Country,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDecodedPlaysByTimeRange = `-- name: GetDecodedPlaysByTimeRange :many
select tx_hash,
    user_id,
    track_id,
    played_at,
    signature,
    city,
    region,
    country,
    created_at
from core_etl_tx_plays
where played_at between $1 and $2
order by played_at desc
limit $3
`

type GetDecodedPlaysByTimeRangeParams struct {
	PlayedAt   pgtype.Timestamptz
	PlayedAt_2 pgtype.Timestamptz
	Limit      int32
}

type GetDecodedPlaysByTimeRangeRow struct {
	TxHash    string
	UserID    string
	TrackID   string
	PlayedAt  pgtype.Timestamptz
	Signature string
	City      pgtype.Text
	Region    pgtype.Text
	Country   pgtype.Text
	CreatedAt pgtype.Timestamptz
}

func (q *Queries) GetDecodedPlaysByTimeRange(ctx context.Context, arg GetDecodedPlaysByTimeRangeParams) ([]GetDecodedPlaysByTimeRangeRow, error) {
	rows, err := q.db.Query(ctx, getDecodedPlaysByTimeRange, arg.PlayedAt, arg.PlayedAt_2, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDecodedPlaysByTimeRangeRow
	for rows.Next() {
		var i GetDecodedPlaysByTimeRangeRow
		if err := rows.Scan(
			&i.TxHash,
			&i.UserID,
			&i.TrackID,
			&i.PlayedAt,
			&i.Signature,
			&i.City,
			&i.Region,
			&i.Country,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDecodedPlaysByTrack = `-- name: GetDecodedPlaysByTrack :many
select tx_hash,
    user_id,
    track_id,
    played_at,
    signature,
    city,
    region,
    country,
    created_at
from core_etl_tx_plays
where track_id = $1
order by played_at desc
limit $2
`

type GetDecodedPlaysByTrackParams struct {
	TrackID string
	Limit   int32
}

type GetDecodedPlaysByTrackRow struct {
	TxHash    string
	UserID    string
	TrackID   string
	PlayedAt  pgtype.Timestamptz
	Signature string
	City      pgtype.Text
	Region    pgtype.Text
	Country   pgtype.Text
	CreatedAt pgtype.Timestamptz
}

func (q *Queries) GetDecodedPlaysByTrack(ctx context.Context, arg GetDecodedPlaysByTrackParams) ([]GetDecodedPlaysByTrackRow, error) {
	rows, err := q.db.Query(ctx, getDecodedPlaysByTrack, arg.TrackID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDecodedPlaysByTrackRow
	for rows.Next() {
		var i GetDecodedPlaysByTrackRow
		if err := rows.Scan(
			&i.TxHash,
			&i.UserID,
			&i.TrackID,
			&i.PlayedAt,
			&i.Signature,
			&i.City,
			&i.Region,
			&i.Country,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDecodedPlaysByUser = `-- name: GetDecodedPlaysByUser :many
select tx_hash,
    user_id,
    track_id,
    played_at,
    signature,
    city,
    region,
    country,
    created_at
from core_etl_tx_plays
where user_id = $1
order by played_at desc
limit $2
`

type GetDecodedPlaysByUserParams struct {
	UserID string
	Limit  int32
}

type GetDecodedPlaysByUserRow struct {
	TxHash    string
	UserID    string
	TrackID   string
	PlayedAt  pgtype.Timestamptz
	Signature string
	City      pgtype.Text
	Region    pgtype.Text
	Country   pgtype.Text
	CreatedAt pgtype.Timestamptz
}

func (q *Queries) GetDecodedPlaysByUser(ctx context.Context, arg GetDecodedPlaysByUserParams) ([]GetDecodedPlaysByUserRow, error) {
	rows, err := q.db.Query(ctx, getDecodedPlaysByUser, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDecodedPlaysByUserRow
	for rows.Next() {
		var i GetDecodedPlaysByUserRow
		if err := rows.Scan(
			&i.TxHash,
			&i.UserID,
			&i.TrackID,
			&i.PlayedAt,
			&i.Signature,
			&i.City,
			&i.Region,
			&i.Country,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDecodedTx = `-- name: GetDecodedTx :one
select id,
    block_height,
    tx_index,
    tx_hash,
    tx_type,
    tx_data,
    created_at
from core_etl_tx
where tx_hash = $1
limit 1
`

func (q *Queries) GetDecodedTx(ctx context.Context, txHash string) (CoreEtlTx, error) {
	row := q.db.QueryRow(ctx, getDecodedTx, txHash)
	var i CoreEtlTx
	err := row.Scan(
		&i.ID,
		&i.BlockHeight,
		&i.TxIndex,
		&i.TxHash,
		&i.TxType,
		&i.TxData,
		&i.CreatedAt,
	)
	return i, err
}

const getDecodedTxsByBlock = `-- name: GetDecodedTxsByBlock :many
select id,
    block_height,
    tx_index,
    tx_hash,
    tx_type,
    tx_data,
    created_at
from core_etl_tx
where block_height = $1
order by tx_index asc
`

func (q *Queries) GetDecodedTxsByBlock(ctx context.Context, blockHeight int64) ([]CoreEtlTx, error) {
	rows, err := q.db.Query(ctx, getDecodedTxsByBlock, blockHeight)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CoreEtlTx
	for rows.Next() {
		var i CoreEtlTx
		if err := rows.Scan(
			&i.ID,
			&i.BlockHeight,
			&i.TxIndex,
			&i.TxHash,
			&i.TxType,
			&i.TxData,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDecodedTxsByType = `-- name: GetDecodedTxsByType :many
select id,
    block_height,
    tx_index,
    tx_hash,
    tx_type,
    tx_data,
    created_at
from core_etl_tx
where tx_type = $1
order by created_at desc
limit $2
`

type GetDecodedTxsByTypeParams struct {
	TxType string
	Limit  int32
}

func (q *Queries) GetDecodedTxsByType(ctx context.Context, arg GetDecodedTxsByTypeParams) ([]CoreEtlTx, error) {
	rows, err := q.db.Query(ctx, getDecodedTxsByType, arg.TxType, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CoreEtlTx
	for rows.Next() {
		var i CoreEtlTx
		if err := rows.Scan(
			&i.ID,
			&i.BlockHeight,
			&i.TxIndex,
			&i.TxHash,
			&i.TxType,
			&i.TxData,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getERN = `-- name: GetERN :one
select id, address, index, tx_hash, sender, message_control_type, raw_message, raw_acknowledgment, block_height from core_ern where address = $1 order by block_height desc limit 1
`

func (q *Queries) GetERN(ctx context.Context, address string) (CoreErn, error) {
	row := q.db.QueryRow(ctx, getERN, address)
	var i CoreErn
	err := row.Scan(
		&i.ID,
		&i.Address,
		&i.Index,
		&i.TxHash,
		&i.Sender,
		&i.MessageControlType,
		&i.RawMessage,
		&i.RawAcknowledgment,
		&i.BlockHeight,
	)
	return i, err
}

const getERNContainingAddress = `-- name: GetERNContainingAddress :one
SELECT
    ern.address as ern_address,
    ern.sender,
    CASE
        WHEN r.address IS NOT NULL THEN 'resource'
        WHEN rel.address IS NOT NULL THEN 'release'
        WHEN p.address IS NOT NULL THEN 'party'
        WHEN d.address IS NOT NULL THEN 'deal'
        ELSE 'unknown'
    END::text as entity_type,
    COALESCE(r.entity_index, rel.entity_index, p.entity_index, d.entity_index, 0)::int as entity_index,
    ern.raw_message
FROM core_ern ern
LEFT JOIN core_resources r ON r.address = $1::text AND r.ern_address = ern.address
LEFT JOIN core_releases rel ON rel.address = $1::text AND rel.ern_address = ern.address
LEFT JOIN core_parties p ON p.address = $1::text AND p.ern_address = ern.address
LEFT JOIN core_deals d ON d.address = $1::text AND d.ern_address = ern.address
WHERE r.address IS NOT NULL OR rel.address IS NOT NULL OR p.address IS NOT NULL OR d.address IS NOT NULL
ORDER BY ern.block_height DESC
LIMIT 1
`

type GetERNContainingAddressRow struct {
	ErnAddress  string
	Sender      string
	EntityType  string
	EntityIndex int32
	RawMessage  []byte
}

func (q *Queries) GetERNContainingAddress(ctx context.Context, dollar_1 string) (GetERNContainingAddressRow, error) {
	row := q.db.QueryRow(ctx, getERNContainingAddress, dollar_1)
	var i GetERNContainingAddressRow
	err := row.Scan(
		&i.ErnAddress,
		&i.Sender,
		&i.EntityType,
		&i.EntityIndex,
		&i.RawMessage,
	)
	return i, err
}

const getERNDeals = `-- name: GetERNDeals :many
select address, ern_address, entity_type, entity_index, tx_hash, block_height, created_at from core_deals where ern_address = $1 order by entity_index
`

func (q *Queries) GetERNDeals(ctx context.Context, ernAddress string) ([]CoreDeal, error) {
	rows, err := q.db.Query(ctx, getERNDeals, ernAddress)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CoreDeal
	for rows.Next() {
		var i CoreDeal
		if err := rows.Scan(
			&i.Address,
			&i.ErnAddress,
			&i.EntityType,
			&i.EntityIndex,
			&i.TxHash,
			&i.BlockHeight,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getERNParties = `-- name: GetERNParties :many
select address, ern_address, entity_type, entity_index, tx_hash, block_height, created_at from core_parties where ern_address = $1 order by entity_index
`

func (q *Queries) GetERNParties(ctx context.Context, ernAddress string) ([]CoreParty, error) {
	rows, err := q.db.Query(ctx, getERNParties, ernAddress)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CoreParty
	for rows.Next() {
		var i CoreParty
		if err := rows.Scan(
			&i.Address,
			&i.ErnAddress,
			&i.EntityType,
			&i.EntityIndex,
			&i.TxHash,
			&i.BlockHeight,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getERNReceipts = `-- name: GetERNReceipts :many
select raw_acknowledgment, index from core_ern where tx_hash = $1
`

type GetERNReceiptsRow struct {
	RawAcknowledgment []byte
	Index             int64
}

func (q *Queries) GetERNReceipts(ctx context.Context, txHash string) ([]GetERNReceiptsRow, error) {
	rows, err := q.db.Query(ctx, getERNReceipts, txHash)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetERNReceiptsRow
	for rows.Next() {
		var i GetERNReceiptsRow
		if err := rows.Scan(&i.RawAcknowledgment, &i.Index); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getERNReleases = `-- name: GetERNReleases :many
select address, ern_address, entity_type, entity_index, tx_hash, block_height, created_at from core_releases where ern_address = $1 order by entity_index
`

func (q *Queries) GetERNReleases(ctx context.Context, ernAddress string) ([]CoreRelease, error) {
	rows, err := q.db.Query(ctx, getERNReleases, ernAddress)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CoreRelease
	for rows.Next() {
		var i CoreRelease
		if err := rows.Scan(
			&i.Address,
			&i.ErnAddress,
			&i.EntityType,
			&i.EntityIndex,
			&i.TxHash,
			&i.BlockHeight,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getERNResources = `-- name: GetERNResources :many
select address, ern_address, entity_type, entity_index, tx_hash, block_height, created_at from core_resources where ern_address = $1 order by entity_index
`

func (q *Queries) GetERNResources(ctx context.Context, ernAddress string) ([]CoreResource, error) {
	rows, err := q.db.Query(ctx, getERNResources, ernAddress)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CoreResource
	for rows.Next() {
		var i CoreResource
		if err := rows.Scan(
			&i.Address,
			&i.ErnAddress,
			&i.EntityType,
			&i.EntityIndex,
			&i.TxHash,
			&i.BlockHeight,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInProgressRollupReports = `-- name: GetInProgressRollupReports :many
select id, address, blocks_proposed, sla_rollup_id
from sla_node_reports
where sla_rollup_id is null
order by address
`

func (q *Queries) GetInProgressRollupReports(ctx context.Context) ([]SlaNodeReport, error) {
	rows, err := q.db.Query(ctx, getInProgressRollupReports)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SlaNodeReport
	for rows.Next() {
		var i SlaNodeReport
		if err := rows.Scan(
			&i.ID,
			&i.Address,
			&i.BlocksProposed,
			&i.SlaRollupID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestAppState = `-- name: GetLatestAppState :one
select block_height,
    app_hash
from core_app_state
order by block_height desc
limit 1
`

type GetLatestAppStateRow struct {
	BlockHeight int64
	AppHash     []byte
}

func (q *Queries) GetLatestAppState(ctx context.Context) (GetLatestAppStateRow, error) {
	row := q.db.QueryRow(ctx, getLatestAppState)
	var i GetLatestAppStateRow
	err := row.Scan(&i.BlockHeight, &i.AppHash)
	return i, err
}

const getLatestBlock = `-- name: GetLatestBlock :one
select rowid, height, chain_id, hash, proposer, created_at
from core_blocks
order by height desc
limit 1
`

func (q *Queries) GetLatestBlock(ctx context.Context) (CoreBlock, error) {
	row := q.db.QueryRow(ctx, getLatestBlock)
	var i CoreBlock
	err := row.Scan(
		&i.Rowid,
		&i.Height,
		&i.ChainID,
		&i.Hash,
		&i.Proposer,
		&i.CreatedAt,
	)
	return i, err
}

const getLatestDecodedTxs = `-- name: GetLatestDecodedTxs :many
select id,
    block_height,
    tx_index,
    tx_hash,
    tx_type,
    tx_data,
    created_at
from core_etl_tx
order by created_at desc
limit $1
`

func (q *Queries) GetLatestDecodedTxs(ctx context.Context, limit int32) ([]CoreEtlTx, error) {
	rows, err := q.db.Query(ctx, getLatestDecodedTxs, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CoreEtlTx
	for rows.Next() {
		var i CoreEtlTx
		if err := rows.Scan(
			&i.ID,
			&i.BlockHeight,
			&i.TxIndex,
			&i.TxHash,
			&i.TxType,
			&i.TxData,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestSlaRollup = `-- name: GetLatestSlaRollup :one
select id, tx_hash, block_start, block_end, time
from sla_rollups
order by time desc
limit 1
`

func (q *Queries) GetLatestSlaRollup(ctx context.Context) (SlaRollup, error) {
	row := q.db.QueryRow(ctx, getLatestSlaRollup)
	var i SlaRollup
	err := row.Scan(
		&i.ID,
		&i.TxHash,
		&i.BlockStart,
		&i.BlockEnd,
		&i.Time,
	)
	return i, err
}

const getMEAD = `-- name: GetMEAD :one
select id, address, tx_hash, index, sender, resource_addresses, release_addresses, raw_message, raw_acknowledgment, block_height from core_mead where address = $1 order by block_height desc limit 1
`

func (q *Queries) GetMEAD(ctx context.Context, address string) (CoreMead, error) {
	row := q.db.QueryRow(ctx, getMEAD, address)
	var i CoreMead
	err := row.Scan(
		&i.ID,
		&i.Address,
		&i.TxHash,
		&i.Index,
		&i.Sender,
		&i.ResourceAddresses,
		&i.ReleaseAddresses,
		&i.RawMessage,
		&i.RawAcknowledgment,
		&i.BlockHeight,
	)
	return i, err
}

const getMEADReceipts = `-- name: GetMEADReceipts :many
select raw_acknowledgment, index from core_mead where tx_hash = $1
`

type GetMEADReceiptsRow struct {
	RawAcknowledgment []byte
	Index             int64
}

func (q *Queries) GetMEADReceipts(ctx context.Context, txHash string) ([]GetMEADReceiptsRow, error) {
	rows, err := q.db.Query(ctx, getMEADReceipts, txHash)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMEADReceiptsRow
	for rows.Next() {
		var i GetMEADReceiptsRow
		if err := rows.Scan(&i.RawAcknowledgment, &i.Index); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNodeByEndpoint = `-- name: GetNodeByEndpoint :one
select rowid, pub_key, endpoint, eth_address, comet_address, eth_block, node_type, sp_id, comet_pub_key
from core_validators
where endpoint = $1
limit 1
`

func (q *Queries) GetNodeByEndpoint(ctx context.Context, endpoint string) (CoreValidator, error) {
	row := q.db.QueryRow(ctx, getNodeByEndpoint, endpoint)
	var i CoreValidator
	err := row.Scan(
		&i.Rowid,
		&i.PubKey,
		&i.Endpoint,
		&i.EthAddress,
		&i.CometAddress,
		&i.EthBlock,
		&i.NodeType,
		&i.SpID,
		&i.CometPubKey,
	)
	return i, err
}

const getNodesByEndpoints = `-- name: GetNodesByEndpoints :many
select rowid, pub_key, endpoint, eth_address, comet_address, eth_block, node_type, sp_id, comet_pub_key
from core_validators
where endpoint = any($1::text [])
`

func (q *Queries) GetNodesByEndpoints(ctx context.Context, dollar_1 []string) ([]CoreValidator, error) {
	rows, err := q.db.Query(ctx, getNodesByEndpoints, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CoreValidator
	for rows.Next() {
		var i CoreValidator
		if err := rows.Scan(
			&i.Rowid,
			&i.PubKey,
			&i.Endpoint,
			&i.EthAddress,
			&i.CometAddress,
			&i.EthBlock,
			&i.NodeType,
			&i.SpID,
			&i.CometPubKey,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPIE = `-- name: GetPIE :one
select id, address, tx_hash, index, sender, party_addresses, raw_message, raw_acknowledgment, block_height from core_pie where address = $1 order by block_height desc limit 1
`

func (q *Queries) GetPIE(ctx context.Context, address string) (CorePie, error) {
	row := q.db.QueryRow(ctx, getPIE, address)
	var i CorePie
	err := row.Scan(
		&i.ID,
		&i.Address,
		&i.TxHash,
		&i.Index,
		&i.Sender,
		&i.PartyAddresses,
		&i.RawMessage,
		&i.RawAcknowledgment,
		&i.BlockHeight,
	)
	return i, err
}

const getPIEReceipts = `-- name: GetPIEReceipts :many
select raw_acknowledgment, index from core_pie where tx_hash = $1
`

type GetPIEReceiptsRow struct {
	RawAcknowledgment []byte
	Index             int64
}

func (q *Queries) GetPIEReceipts(ctx context.Context, txHash string) ([]GetPIEReceiptsRow, error) {
	rows, err := q.db.Query(ctx, getPIEReceipts, txHash)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPIEReceiptsRow
	for rows.Next() {
		var i GetPIEReceiptsRow
		if err := rows.Scan(&i.RawAcknowledgment, &i.Index); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPreviousSlaRollupFromId = `-- name: GetPreviousSlaRollupFromId :one
select id, tx_hash, block_start, block_end, time
from sla_rollups
where time < (
        select time
        from sla_rollups sr
        where sr.id = $1
    )
order by time desc
limit 1
`

func (q *Queries) GetPreviousSlaRollupFromId(ctx context.Context, id int32) (SlaRollup, error) {
	row := q.db.QueryRow(ctx, getPreviousSlaRollupFromId, id)
	var i SlaRollup
	err := row.Scan(
		&i.ID,
		&i.TxHash,
		&i.BlockStart,
		&i.BlockEnd,
		&i.Time,
	)
	return i, err
}

const getRecentBlocks = `-- name: GetRecentBlocks :many
select rowid, height, chain_id, hash, proposer, created_at
from core_blocks
order by created_at desc
limit $1
`

func (q *Queries) GetRecentBlocks(ctx context.Context, limit int32) ([]CoreBlock, error) {
	rows, err := q.db.Query(ctx, getRecentBlocks, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CoreBlock
	for rows.Next() {
		var i CoreBlock
		if err := rows.Scan(
			&i.Rowid,
			&i.Height,
			&i.ChainID,
			&i.Hash,
			&i.Proposer,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentRollupsForAllNodes = `-- name: GetRecentRollupsForAllNodes :many
with recent_rollups as (
    select id, tx_hash, block_start, block_end, time
    from sla_rollups
    where sla_rollups.id <= $1
    order by time desc
    limit $2
)
select rr.id,
    rr.tx_hash,
    rr.block_start,
    rr.block_end,
    rr.time,
    nr.address,
    nr.blocks_proposed
from recent_rollups rr
    left join sla_node_reports nr on rr.id = nr.sla_rollup_id
order by rr.time
`

type GetRecentRollupsForAllNodesParams struct {
	ID    int32
	Limit int32
}

type GetRecentRollupsForAllNodesRow struct {
	ID             int32
	TxHash         string
	BlockStart     int64
	BlockEnd       int64
	Time           pgtype.Timestamp
	Address        pgtype.Text
	BlocksProposed pgtype.Int4
}

func (q *Queries) GetRecentRollupsForAllNodes(ctx context.Context, arg GetRecentRollupsForAllNodesParams) ([]GetRecentRollupsForAllNodesRow, error) {
	rows, err := q.db.Query(ctx, getRecentRollupsForAllNodes, arg.ID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRecentRollupsForAllNodesRow
	for rows.Next() {
		var i GetRecentRollupsForAllNodesRow
		if err := rows.Scan(
			&i.ID,
			&i.TxHash,
			&i.BlockStart,
			&i.BlockEnd,
			&i.Time,
			&i.Address,
			&i.BlocksProposed,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentRollupsForNode = `-- name: GetRecentRollupsForNode :many
with recent_rollups as (
    select id, tx_hash, block_start, block_end, time
    from sla_rollups
    order by time desc
    limit $1 
)
select rr.id,
    rr.tx_hash,
    rr.block_start,
    rr.block_end,
    rr.time,
    nr.address,
    nr.blocks_proposed
from recent_rollups rr
    left join sla_node_reports nr on rr.id = nr.sla_rollup_id
    and nr.address = $2
order by rr.time
`

type GetRecentRollupsForNodeParams struct {
	Limit   int32
	Address string
}

type GetRecentRollupsForNodeRow struct {
	ID             int32
	TxHash         string
	BlockStart     int64
	BlockEnd       int64
	Time           pgtype.Timestamp
	Address        pgtype.Text
	BlocksProposed pgtype.Int4
}

func (q *Queries) GetRecentRollupsForNode(ctx context.Context, arg GetRecentRollupsForNodeParams) ([]GetRecentRollupsForNodeRow, error) {
	rows, err := q.db.Query(ctx, getRecentRollupsForNode, arg.Limit, arg.Address)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRecentRollupsForNodeRow
	for rows.Next() {
		var i GetRecentRollupsForNodeRow
		if err := rows.Scan(
			&i.ID,
			&i.TxHash,
			&i.BlockStart,
			&i.BlockEnd,
			&i.Time,
			&i.Address,
			&i.BlocksProposed,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentTxs = `-- name: GetRecentTxs :many
select rowid, block_id, index, tx_hash, transaction, created_at
from core_transactions
order by created_at desc
limit $1
`

func (q *Queries) GetRecentTxs(ctx context.Context, limit int32) ([]CoreTransaction, error) {
	rows, err := q.db.Query(ctx, getRecentTxs, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CoreTransaction
	for rows.Next() {
		var i CoreTransaction
		if err := rows.Scan(
			&i.Rowid,
			&i.BlockID,
			&i.Index,
			&i.TxHash,
			&i.Transaction,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecordingsForTrack = `-- name: GetRecordingsForTrack :many
select id, sound_recording_id, track_id, cid, encoding_details
from sound_recordings
where track_id = $1
`

func (q *Queries) GetRecordingsForTrack(ctx context.Context, trackID string) ([]SoundRecording, error) {
	rows, err := q.db.Query(ctx, getRecordingsForTrack, trackID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SoundRecording
	for rows.Next() {
		var i SoundRecording
		if err := rows.Scan(
			&i.ID,
			&i.SoundRecordingID,
			&i.TrackID,
			&i.Cid,
			&i.EncodingDetails,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRegisteredNodeByCometAddress = `-- name: GetRegisteredNodeByCometAddress :one
select rowid, pub_key, endpoint, eth_address, comet_address, eth_block, node_type, sp_id, comet_pub_key
from core_validators
where comet_address = $1
`

func (q *Queries) GetRegisteredNodeByCometAddress(ctx context.Context, cometAddress string) (CoreValidator, error) {
	row := q.db.QueryRow(ctx, getRegisteredNodeByCometAddress, cometAddress)
	var i CoreValidator
	err := row.Scan(
		&i.Rowid,
		&i.PubKey,
		&i.Endpoint,
		&i.EthAddress,
		&i.CometAddress,
		&i.EthBlock,
		&i.NodeType,
		&i.SpID,
		&i.CometPubKey,
	)
	return i, err
}

const getRegisteredNodeByEthAddress = `-- name: GetRegisteredNodeByEthAddress :one
select rowid, pub_key, endpoint, eth_address, comet_address, eth_block, node_type, sp_id, comet_pub_key
from core_validators
where eth_address = $1
`

func (q *Queries) GetRegisteredNodeByEthAddress(ctx context.Context, ethAddress string) (CoreValidator, error) {
	row := q.db.QueryRow(ctx, getRegisteredNodeByEthAddress, ethAddress)
	var i CoreValidator
	err := row.Scan(
		&i.Rowid,
		&i.PubKey,
		&i.Endpoint,
		&i.EthAddress,
		&i.CometAddress,
		&i.EthBlock,
		&i.NodeType,
		&i.SpID,
		&i.CometPubKey,
	)
	return i, err
}

const getRegisteredNodesByCometAddresses = `-- name: GetRegisteredNodesByCometAddresses :many
select rowid, pub_key, endpoint, eth_address, comet_address, eth_block, node_type, sp_id, comet_pub_key
from core_validators
where comet_address = any($1::text [])
`

func (q *Queries) GetRegisteredNodesByCometAddresses(ctx context.Context, dollar_1 []string) ([]CoreValidator, error) {
	rows, err := q.db.Query(ctx, getRegisteredNodesByCometAddresses, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CoreValidator
	for rows.Next() {
		var i CoreValidator
		if err := rows.Scan(
			&i.Rowid,
			&i.PubKey,
			&i.Endpoint,
			&i.EthAddress,
			&i.CometAddress,
			&i.EthBlock,
			&i.NodeType,
			&i.SpID,
			&i.CometPubKey,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRegisteredNodesByEthAddresses = `-- name: GetRegisteredNodesByEthAddresses :many
select rowid, pub_key, endpoint, eth_address, comet_address, eth_block, node_type, sp_id, comet_pub_key
from core_validators
where eth_address = any($1::text [])
`

func (q *Queries) GetRegisteredNodesByEthAddresses(ctx context.Context, dollar_1 []string) ([]CoreValidator, error) {
	rows, err := q.db.Query(ctx, getRegisteredNodesByEthAddresses, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CoreValidator
	for rows.Next() {
		var i CoreValidator
		if err := rows.Scan(
			&i.Rowid,
			&i.PubKey,
			&i.Endpoint,
			&i.EthAddress,
			&i.CometAddress,
			&i.EthBlock,
			&i.NodeType,
			&i.SpID,
			&i.CometPubKey,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRegisteredNodesByType = `-- name: GetRegisteredNodesByType :many
select rowid, pub_key, endpoint, eth_address, comet_address, eth_block, node_type, sp_id, comet_pub_key
from core_validators
where node_type = $1
`

func (q *Queries) GetRegisteredNodesByType(ctx context.Context, nodeType string) ([]CoreValidator, error) {
	rows, err := q.db.Query(ctx, getRegisteredNodesByType, nodeType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CoreValidator
	for rows.Next() {
		var i CoreValidator
		if err := rows.Scan(
			&i.Rowid,
			&i.PubKey,
			&i.Endpoint,
			&i.EthAddress,
			&i.CometAddress,
			&i.EthBlock,
			&i.NodeType,
			&i.SpID,
			&i.CometPubKey,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReward = `-- name: GetReward :one
select id, address, index, tx_hash, sender, reward_id, name, amount, claim_authorities, raw_message, block_height, created_at, updated_at from core_rewards
where address = $1
order by block_height desc
limit 1
`

func (q *Queries) GetReward(ctx context.Context, address string) (CoreReward, error) {
	row := q.db.QueryRow(ctx, getReward, address)
	var i CoreReward
	err := row.Scan(
		&i.ID,
		&i.Address,
		&i.Index,
		&i.TxHash,
		&i.Sender,
		&i.RewardID,
		&i.Name,
		&i.Amount,
		&i.ClaimAuthorities,
		&i.RawMessage,
		&i.BlockHeight,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRewardByID = `-- name: GetRewardByID :one
select id, address, index, tx_hash, sender, reward_id, name, amount, claim_authorities, raw_message, block_height, created_at, updated_at from core_rewards
where reward_id = $1
order by block_height desc
limit 1
`

func (q *Queries) GetRewardByID(ctx context.Context, rewardID string) (CoreReward, error) {
	row := q.db.QueryRow(ctx, getRewardByID, rewardID)
	var i CoreReward
	err := row.Scan(
		&i.ID,
		&i.Address,
		&i.Index,
		&i.TxHash,
		&i.Sender,
		&i.RewardID,
		&i.Name,
		&i.Amount,
		&i.ClaimAuthorities,
		&i.RawMessage,
		&i.BlockHeight,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRewardByTxHash = `-- name: GetRewardByTxHash :one
select id, address, index, tx_hash, sender, reward_id, name, amount, claim_authorities, raw_message, block_height, created_at, updated_at from core_rewards
where tx_hash = $1
order by block_height desc
limit 1
`

func (q *Queries) GetRewardByTxHash(ctx context.Context, txHash string) (CoreReward, error) {
	row := q.db.QueryRow(ctx, getRewardByTxHash, txHash)
	var i CoreReward
	err := row.Scan(
		&i.ID,
		&i.Address,
		&i.Index,
		&i.TxHash,
		&i.Sender,
		&i.RewardID,
		&i.Name,
		&i.Amount,
		&i.ClaimAuthorities,
		&i.RawMessage,
		&i.BlockHeight,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRewardsByClaimAuthority = `-- name: GetRewardsByClaimAuthority :many
select id, address, index, tx_hash, sender, reward_id, name, amount, claim_authorities, raw_message, block_height, created_at, updated_at
from core_rewards
where $1::text = any(claim_authorities)
order by address
`

func (q *Queries) GetRewardsByClaimAuthority(ctx context.Context, dollar_1 string) ([]CoreReward, error) {
	rows, err := q.db.Query(ctx, getRewardsByClaimAuthority, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CoreReward
	for rows.Next() {
		var i CoreReward
		if err := rows.Scan(
			&i.ID,
			&i.Address,
			&i.Index,
			&i.TxHash,
			&i.Sender,
			&i.RewardID,
			&i.Name,
			&i.Amount,
			&i.ClaimAuthorities,
			&i.RawMessage,
			&i.BlockHeight,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRollupReportForNodeAndId = `-- name: GetRollupReportForNodeAndId :one
select id, address, blocks_proposed, sla_rollup_id
from sla_node_reports
where address = $1
    and sla_rollup_id = $2
`

type GetRollupReportForNodeAndIdParams struct {
	Address     string
	SlaRollupID pgtype.Int4
}

func (q *Queries) GetRollupReportForNodeAndId(ctx context.Context, arg GetRollupReportForNodeAndIdParams) (SlaNodeReport, error) {
	row := q.db.QueryRow(ctx, getRollupReportForNodeAndId, arg.Address, arg.SlaRollupID)
	var i SlaNodeReport
	err := row.Scan(
		&i.ID,
		&i.Address,
		&i.BlocksProposed,
		&i.SlaRollupID,
	)
	return i, err
}

const getRollupReportsForId = `-- name: GetRollupReportsForId :many
select id, address, blocks_proposed, sla_rollup_id
from sla_node_reports
where sla_rollup_id = $1
order by address
`

func (q *Queries) GetRollupReportsForId(ctx context.Context, slaRollupID pgtype.Int4) ([]SlaNodeReport, error) {
	rows, err := q.db.Query(ctx, getRollupReportsForId, slaRollupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SlaNodeReport
	for rows.Next() {
		var i SlaNodeReport
		if err := rows.Scan(
			&i.ID,
			&i.Address,
			&i.BlocksProposed,
			&i.SlaRollupID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRollupReportsForNodeInTimeRange = `-- name: GetRollupReportsForNodeInTimeRange :many
select 
    sr.id,
    sr.tx_hash,
    sr.block_start,
    sr.block_end,
    sr.time,
    nr.address,
    nr.blocks_proposed,
    (
        select count(distinct address)
        from sla_node_reports
        where sla_rollup_id = sr.id
    ) as validator_count
from 
    sla_rollups sr
left join sla_node_reports nr
    on nr.sla_rollup_id = sr.id and nr.address = $1
where sr.time > $2 and sr.time <= $3
order by sr.time
`

type GetRollupReportsForNodeInTimeRangeParams struct {
	Address string
	Time    pgtype.Timestamp
	Time_2  pgtype.Timestamp
}

type GetRollupReportsForNodeInTimeRangeRow struct {
	ID             int32
	TxHash         string
	BlockStart     int64
	BlockEnd       int64
	Time           pgtype.Timestamp
	Address        pgtype.Text
	BlocksProposed pgtype.Int4
	ValidatorCount int64
}

func (q *Queries) GetRollupReportsForNodeInTimeRange(ctx context.Context, arg GetRollupReportsForNodeInTimeRangeParams) ([]GetRollupReportsForNodeInTimeRangeRow, error) {
	rows, err := q.db.Query(ctx, getRollupReportsForNodeInTimeRange, arg.Address, arg.Time, arg.Time_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRollupReportsForNodeInTimeRangeRow
	for rows.Next() {
		var i GetRollupReportsForNodeInTimeRangeRow
		if err := rows.Scan(
			&i.ID,
			&i.TxHash,
			&i.BlockStart,
			&i.BlockEnd,
			&i.Time,
			&i.Address,
			&i.BlocksProposed,
			&i.ValidatorCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRollupReportsForNodesInTimeRange = `-- name: GetRollupReportsForNodesInTimeRange :many
with address_list as (
    select unnest($1::text[])::text as address
)
select 
    sr.id,
    sr.tx_hash,
    sr.block_start,
    sr.block_end,
    sr.time,
    al.address,
    nr.blocks_proposed,
    (
        select count(distinct address)
        from sla_node_reports
        where sla_rollup_id = sr.id
    ) as validator_count
from 
    sla_rollups sr
join address_list al on true
left join sla_node_reports nr
    on nr.sla_rollup_id = sr.id 
    and nr.address = al.address
where sr.time > $2 and sr.time <= $3
order by sr.time, al.address
`

type GetRollupReportsForNodesInTimeRangeParams struct {
	Column1 []string
	Time    pgtype.Timestamp
	Time_2  pgtype.Timestamp
}

type GetRollupReportsForNodesInTimeRangeRow struct {
	ID             int32
	TxHash         string
	BlockStart     int64
	BlockEnd       int64
	Time           pgtype.Timestamp
	Address        string
	BlocksProposed pgtype.Int4
	ValidatorCount int64
}

func (q *Queries) GetRollupReportsForNodesInTimeRange(ctx context.Context, arg GetRollupReportsForNodesInTimeRangeParams) ([]GetRollupReportsForNodesInTimeRangeRow, error) {
	rows, err := q.db.Query(ctx, getRollupReportsForNodesInTimeRange, arg.Column1, arg.Time, arg.Time_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRollupReportsForNodesInTimeRangeRow
	for rows.Next() {
		var i GetRollupReportsForNodesInTimeRangeRow
		if err := rows.Scan(
			&i.ID,
			&i.TxHash,
			&i.BlockStart,
			&i.BlockEnd,
			&i.Time,
			&i.Address,
			&i.BlocksProposed,
			&i.ValidatorCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSlaRollupWithBlockEnd = `-- name: GetSlaRollupWithBlockEnd :one
select id, tx_hash, block_start, block_end, time
from sla_rollups
where block_end = $1
`

func (q *Queries) GetSlaRollupWithBlockEnd(ctx context.Context, blockEnd int64) (SlaRollup, error) {
	row := q.db.QueryRow(ctx, getSlaRollupWithBlockEnd, blockEnd)
	var i SlaRollup
	err := row.Scan(
		&i.ID,
		&i.TxHash,
		&i.BlockStart,
		&i.BlockEnd,
		&i.Time,
	)
	return i, err
}

const getSlaRollupWithId = `-- name: GetSlaRollupWithId :one
select id, tx_hash, block_start, block_end, time
from sla_rollups
where id = $1
`

func (q *Queries) GetSlaRollupWithId(ctx context.Context, id int32) (SlaRollup, error) {
	row := q.db.QueryRow(ctx, getSlaRollupWithId, id)
	var i SlaRollup
	err := row.Scan(
		&i.ID,
		&i.TxHash,
		&i.BlockStart,
		&i.BlockEnd,
		&i.Time,
	)
	return i, err
}

const getSlaRollupWithTimestamp = `-- name: GetSlaRollupWithTimestamp :one
select id, tx_hash, block_start, block_end, time
from sla_rollups
where time = $1
`

func (q *Queries) GetSlaRollupWithTimestamp(ctx context.Context, time pgtype.Timestamp) (SlaRollup, error) {
	row := q.db.QueryRow(ctx, getSlaRollupWithTimestamp, time)
	var i SlaRollup
	err := row.Scan(
		&i.ID,
		&i.TxHash,
		&i.BlockStart,
		&i.BlockEnd,
		&i.Time,
	)
	return i, err
}

const getStorageProof = `-- name: GetStorageProof :one
select id, block_height, address, cid, proof_signature, proof, prover_addresses, status
from storage_proofs
where block_height = $1
    and address = $2
`

type GetStorageProofParams struct {
	BlockHeight int64
	Address     string
}

func (q *Queries) GetStorageProof(ctx context.Context, arg GetStorageProofParams) (StorageProof, error) {
	row := q.db.QueryRow(ctx, getStorageProof, arg.BlockHeight, arg.Address)
	var i StorageProof
	err := row.Scan(
		&i.ID,
		&i.BlockHeight,
		&i.Address,
		&i.Cid,
		&i.ProofSignature,
		&i.Proof,
		&i.ProverAddresses,
		&i.Status,
	)
	return i, err
}

const getStorageProofPeers = `-- name: GetStorageProofPeers :one
select prover_addresses
from storage_proof_peers
where block_height = $1
`

func (q *Queries) GetStorageProofPeers(ctx context.Context, blockHeight int64) ([]string, error) {
	row := q.db.QueryRow(ctx, getStorageProofPeers, blockHeight)
	var prover_addresses []string
	err := row.Scan(&prover_addresses)
	return prover_addresses, err
}

const getStorageProofRollupForNode = `-- name: GetStorageProofRollupForNode :one
select address,
    count(*) filter (
        where status = 'fail'
    ) as failed_count,
    count(*) as total_count
from storage_proofs
where address = $1
    and block_height >= $2
    and block_height <= $3
group by address
`

type GetStorageProofRollupForNodeParams struct {
	Address       string
	BlockHeight   int64
	BlockHeight_2 int64
}

type GetStorageProofRollupForNodeRow struct {
	Address     string
	FailedCount int64
	TotalCount  int64
}

func (q *Queries) GetStorageProofRollupForNode(ctx context.Context, arg GetStorageProofRollupForNodeParams) (GetStorageProofRollupForNodeRow, error) {
	row := q.db.QueryRow(ctx, getStorageProofRollupForNode, arg.Address, arg.BlockHeight, arg.BlockHeight_2)
	var i GetStorageProofRollupForNodeRow
	err := row.Scan(&i.Address, &i.FailedCount, &i.TotalCount)
	return i, err
}

const getStorageProofRollups = `-- name: GetStorageProofRollups :many
select address,
    count(*) filter (
        where status = 'fail'
    ) as failed_count,
    count(*) as total_count
from storage_proofs
where block_height >= $1
    and block_height <= $2
group by address
`

type GetStorageProofRollupsParams struct {
	BlockHeight   int64
	BlockHeight_2 int64
}

type GetStorageProofRollupsRow struct {
	Address     string
	FailedCount int64
	TotalCount  int64
}

func (q *Queries) GetStorageProofRollups(ctx context.Context, arg GetStorageProofRollupsParams) ([]GetStorageProofRollupsRow, error) {
	rows, err := q.db.Query(ctx, getStorageProofRollups, arg.BlockHeight, arg.BlockHeight_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStorageProofRollupsRow
	for rows.Next() {
		var i GetStorageProofRollupsRow
		if err := rows.Scan(&i.Address, &i.FailedCount, &i.TotalCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStorageProofs = `-- name: GetStorageProofs :many
select id, block_height, address, cid, proof_signature, proof, prover_addresses, status
from storage_proofs
where block_height = $1
`

func (q *Queries) GetStorageProofs(ctx context.Context, blockHeight int64) ([]StorageProof, error) {
	rows, err := q.db.Query(ctx, getStorageProofs, blockHeight)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []StorageProof
	for rows.Next() {
		var i StorageProof
		if err := rows.Scan(
			&i.ID,
			&i.BlockHeight,
			&i.Address,
			&i.Cid,
			&i.ProofSignature,
			&i.Proof,
			&i.ProverAddresses,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStorageProofsForNodeInRange = `-- name: GetStorageProofsForNodeInRange :many
select id, block_height, address, cid, proof_signature, proof, prover_addresses, status
from storage_proofs
where block_height in (
        select block_height
        from storage_proofs sp
        where sp.block_height >= $1
            and sp.block_height <= $2
            and sp.address = $3
    )
`

type GetStorageProofsForNodeInRangeParams struct {
	BlockHeight   int64
	BlockHeight_2 int64
	Address       string
}

func (q *Queries) GetStorageProofsForNodeInRange(ctx context.Context, arg GetStorageProofsForNodeInRangeParams) ([]StorageProof, error) {
	rows, err := q.db.Query(ctx, getStorageProofsForNodeInRange, arg.BlockHeight, arg.BlockHeight_2, arg.Address)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []StorageProof
	for rows.Next() {
		var i StorageProof
		if err := rows.Scan(
			&i.ID,
			&i.BlockHeight,
			&i.Address,
			&i.Cid,
			&i.ProofSignature,
			&i.Proof,
			&i.ProverAddresses,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTx = `-- name: GetTx :one
select rowid, block_id, index, tx_hash, transaction, created_at
from core_transactions
where lower(tx_hash) = lower($1)
limit 1
`

func (q *Queries) GetTx(ctx context.Context, lower string) (CoreTransaction, error) {
	row := q.db.QueryRow(ctx, getTx, lower)
	var i CoreTransaction
	err := row.Scan(
		&i.Rowid,
		&i.BlockID,
		&i.Index,
		&i.TxHash,
		&i.Transaction,
		&i.CreatedAt,
	)
	return i, err
}

const getValidatorHistoryForID = `-- name: GetValidatorHistoryForID :one
select rowid, endpoint, eth_address, comet_address, sp_id, service_type, event_type, event_time, event_block
from validator_history
where sp_id = $1
    and service_type = $2
order by event_time desc
limit 1
`

type GetValidatorHistoryForIDParams struct {
	SpID        int64
	ServiceType string
}

func (q *Queries) GetValidatorHistoryForID(ctx context.Context, arg GetValidatorHistoryForIDParams) (ValidatorHistory, error) {
	row := q.db.QueryRow(ctx, getValidatorHistoryForID, arg.SpID, arg.ServiceType)
	var i ValidatorHistory
	err := row.Scan(
		&i.Rowid,
		&i.Endpoint,
		&i.EthAddress,
		&i.CometAddress,
		&i.SpID,
		&i.ServiceType,
		&i.EventType,
		&i.EventTime,
		&i.EventBlock,
	)
	return i, err
}

const hasAccessToTrackRelease = `-- name: HasAccessToTrackRelease :one
select exists (
        select 1
        from access_keys
        where track_id = $1
            and pub_key = $2
    )
`

type HasAccessToTrackReleaseParams struct {
	TrackID string
	PubKey  string
}

func (q *Queries) HasAccessToTrackRelease(ctx context.Context, arg HasAccessToTrackReleaseParams) (bool, error) {
	row := q.db.QueryRow(ctx, hasAccessToTrackRelease, arg.TrackID, arg.PubKey)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const totalBlocks = `-- name: TotalBlocks :one
select count(*)
from core_blocks
`

func (q *Queries) TotalBlocks(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, totalBlocks)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const totalTransactions = `-- name: TotalTransactions :one
select count(*)
from core_tx_stats
`

func (q *Queries) TotalTransactions(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, totalTransactions)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const totalTransactionsByType = `-- name: TotalTransactionsByType :one
select count(*)
from core_tx_stats
where tx_type = $1
`

func (q *Queries) TotalTransactionsByType(ctx context.Context, txType string) (int64, error) {
	row := q.db.QueryRow(ctx, totalTransactionsByType, txType)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const totalTxResults = `-- name: TotalTxResults :one
select count(tx_hash)
from core_transactions
`

func (q *Queries) TotalTxResults(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, totalTxResults)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const totalValidators = `-- name: TotalValidators :one
select count(*)
from core_validators
`

func (q *Queries) TotalValidators(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, totalValidators)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const txsPerHour = `-- name: TxsPerHour :many
select date_trunc('hour', created_at)::timestamp as hour,
    tx_type,
    count(*) as tx_count
from core_tx_stats
where created_at >= now() - interval '1 day'
group by hour,
    tx_type
order by hour asc
`

type TxsPerHourRow struct {
	Hour    pgtype.Timestamp
	TxType  string
	TxCount int64
}

func (q *Queries) TxsPerHour(ctx context.Context) ([]TxsPerHourRow, error) {
	rows, err := q.db.Query(ctx, txsPerHour)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TxsPerHourRow
	for rows.Next() {
		var i TxsPerHourRow
		if err := rows.Scan(&i.Hour, &i.TxType, &i.TxCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
